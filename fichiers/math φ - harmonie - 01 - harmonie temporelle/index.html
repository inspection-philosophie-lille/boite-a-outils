<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>harmonie temporelle</title>
    <meta name="description" content="Générer des rythmes euclidiens avec différents instruments pour un style bossa nova." />
    <link rel="icon" href="../../src/favicon.ico">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/10.1.0/nouislider.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #e0e0e0;
            color: #333;
            line-height: 1.6;
            margin: 0;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .container {
            background: #e0e0e0;
            padding: 15px;
            border-radius: 15px;
            box-shadow: 8px 8px 16px #bebebe, -8px -8px 16px #ffffff;
            width: 100%;
            max-width: 90vw;
            box-sizing: border-box;
        }

        header h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: clamp(1.8em, 5vw, 2.2em);
            text-shadow: 2px 2px 4px #bebebe, -2px -2px 4px #ffffff;
        }

        .transport {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
            gap: 10px;
        }

        #play-pause-button,
        .custom-file-upload,
        #export-button,
        .bpm-control,
        #add-sequencer {
            padding: 10px;
            font-size: clamp(0.8em, 3vw, 0.9em);
            font-weight: 600;
            background: #e0e0e0;
            color: #2c3e50;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 4px 4px 8px #bebebe, -4px -4px 8px #ffffff;
            transition: all 0.2s ease;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .custom-file-upload {
            line-height: 1;
        }

        #play-pause-button:hover,
        .custom-file-upload:hover,
        #export-button:hover,
        .bpm-control:hover,
        #add-sequencer:hover {
            box-shadow: inset 4px 4px 8px #bebebe, inset -4px -4px 8px #ffffff;
        }

        #play-pause-button:active,
        .custom-file-upload:active,
        #export-button:active,
        .bpm-control:active,
        #add-sequencer:active {
            transform: translateY(2px);
            box-shadow: inset 2px 2px 4px #bebebe, inset -2px -2px 4px #ffffff;
        }

        #play-pause-button.playing {
            background: linear-gradient(145deg, #cacaca, #f0f0f0);
            color: #dc3545;
        }

        .bpm-control {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px;
        }

        .bpm-control label {
            font-size: clamp(0.9em, 3vw, 1em);
            font-weight: 600;
            color: #2c3e50;
            margin-right: 8px;
        }

        .bpm-control input {
            width: 60px;
            padding: 4px;
            font-size: clamp(0.8em, 3vw, 0.9em);
            border: none;
            border-radius: 8px;
            background: #e0e0e0;
            box-shadow: inset 2px 2px 4px #bebebe, inset -2px -2px 4px #ffffff;
            text-align: center;
            color: #2c3e50;
            transition: all 0.2s ease;
            height: 30px;
        }

        .bpm-control input:focus {
            outline: none;
            box-shadow: inset 1px 1px 2px #bebebe, inset -1px -1px 2px #ffffff;
        }

        input[type="file"] {
            display: none;
        }

        .sequencer {
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 10px;
            background: #e0e0e0;
            box-shadow: 4px 4px 10px #bebebe, -4px -4px 10px #ffffff;
        }

        .sequencer-controls {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            flex-wrap: nowrap;
        }

        .instrument-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label[for^="instrument-"] {
            font-weight: 600;
            font-size: clamp(0.8em, 2.5vw, 0.85em);
            color: #2c3e50;
            white-space: nowrap;
            margin-left: 10px;
        }

        .control-group label[for^="slider-"] {
            font-weight: 600;
            font-size: clamp(0.8em, 2.5vw, 0.85em);
            color: #2c3e50;
            white-space: nowrap;
            margin-left: 10px;
        }

        .control-group select {
            width: 100%;
            max-width: 110px;
            padding: 6px;
            border: none;
            border-radius: 8px;
            background: #e0e0e0;
            box-shadow: inset 2px 2px 4px #bebebe, inset -2px -2px 4px #ffffff;
            color: #2c3e50;
            transition: all 0.2s ease;
            appearance: none;
            padding-right: 25px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%232c3e50'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 10px;
            height: 30px;
            flex: 0 0 auto;
        }

        .noUi-target {
            background: #e0e0e0;
            border: none;
            border-radius: 8px;
            box-shadow: inset 2px 2px 4px #bebebe, inset -2px -2px 4px #ffffff;
            height: 20px;
            margin: 0 6px;
            flex: 1;
            box-sizing: border-box;
            position: relative;
            display: block;
            visibility: visible;
            opacity: 1;
            z-index: 1;
            will-change: transform;
        }

        .noUi-connect {
            background: linear-gradient(145deg, #cacaca, #f0f0f0);
            height: 100%;
        }

        .noUi-handle {
            width: 12px;
            height: 12px;
            background: #e0e0e0;
            border-radius: 50%;
            box-shadow: 2px 2px 4px #bebebe, -2px -2px 4px #ffffff;
            cursor: pointer;
            border: none;
            top: 4px;
            transform: translateY(0);
            right: -6px;
        }

        .noUi-handle:after, .noUi-handle:before {
            display: none;
        }

        .noUi-tooltip {
            display: none;
        }

        .concentric-steps {
            position: relative;
            margin: 15px auto;
            width: 100%;
            aspect-ratio: 1 / 1;
        }

        .step {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            box-shadow: 2px 2px 4px #bebebe, -2px -2px 4px #ffffff;
            transition: all 0.2s ease;
            transform: translate(-50%, -50%);
        }

        .step.active {
            box-shadow: inset 2px 2px 4px #bebebe, inset -2px -2px 4px #ffffff;
        }

        .step.current {
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 4px 4px 8px #bebebe, -4px -4px 8px #ffffff;
        }

        .needle {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -100%) rotate(0deg);
            transform-origin: bottom center;
            transition: transform 0.1s linear;
        }

        .needle-svg {
            fill: #2c3e50;
        }

        .needle.playing {
            animation: rotate linear infinite;
        }

        @keyframes rotate {
            from {
                transform: translate(-50%, -100%) rotate(0deg);
            }
            to {
                transform: translate(-50%, -100%) rotate(360deg);
            }
        }

        #add-sequencer {
            padding: 8px 12px;
            font-size: clamp(0.9em, 3vw, 1em);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            background: linear-gradient(145deg, #28a745, #218838);
            box-shadow: 4px 4px 8px #bebebe, -4px -4px 8px #ffffff;
            transition: all 0.2s ease;
            width: 100%;
            height: 45px;
            margin: 10px auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #add-sequencer:hover {
            box-shadow: inset 2px 2px 4px #bebebe, inset -2px -2px 4px #ffffff;
        }

        #add-sequencer:active {
            transform: translateY(2px);
            box-shadow: inset 1px 1px 2px #bebebe, inset -1px -1px 2px #ffffff;
        }

        .remove-sequencer {
            padding: 8px 12px;
            font-size: clamp(0.8em, 3vw, 0.9em);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            background: linear-gradient(145deg, #dc3545, #c82333);
            box-shadow: 4px 4px 8px #bebebe, -4px -4px 8px #ffffff;
            transition: all 0.2s ease;
            width: 100%;
            max-width: 100px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
        }

        .remove-sequencer:hover {
            box-shadow: inset 2px 2px 4px #bebebe, inset -2px -2px 4px #ffffff;
        }

        .remove-sequencer:active {
            transform: translateY(2px);
            box-shadow: inset 1px 1px 2px #bebebe, inset -1px -1px 2px #ffffff;
        }

        footer {
            text-align: center;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid transparent;
            font-size: clamp(0.8em, 2.5vw, 0.9em);
            color: #2c3e50;
        }

        footer a {
            color: #007bff;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        footer a:hover {
            color: #0056b3;
            text-decoration: underline;
        }

        @media (max-width: 600px) {
            body {
                padding: 5px;
            }

            .container {
                padding: 10px;
                max-width: 95vw;
            }

            header h1 {
                font-size: clamp(1.5em, 4.5vw, 1.8em);
            }

            .transport {
                flex-direction: column;
                gap: 8px;
            }

            #play-pause-button,
            .custom-file-upload,
            #export-button,
            .bpm-control,
            #add-sequencer {
                width: 100%;
                height: 40px;
                font-size: clamp(0.7em, 2.8vw, 0.8em);
            }

            .bpm-control input {
                width: 50px;
                height: 25px;
                font-size: clamp(0.7em, 2.8vw, 0.8em);
            }

            .concentric-steps {
                max-width: 80vw;
                margin: 10px auto;
            }

            .step {
                width: 12px;
                height: 12px;
            }

            .control-group {
                flex-wrap: wrap;
                width: 100%;
                align-items: flex-start;
                margin: 0;
            }

            .instrument-group {
                display: flex;
                align-items: flex-start;
                gap: 10px;
                flex-wrap: nowrap;
                width: 100%;
            }

            .control-group select {
                width: 100%;
                max-width: 150px;
            }

            .control-group label[for^="slider-"] {
                margin-top: -8px;
                margin-left: 10px;
            }

            .noUi-target {
                height: 22px;
            }

            .noUi-handle {
                top: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <p style="margin: 10px; line-height: 40px; text-align: center; color:red; font-size:clamp(1.8em, 5vw, 2em); font-weight: bold; font-family: 'Muli', sans-serif">harmonie temporelle</p>
            <p style="margin: 0; line-height: 1; text-align: center; color:black; font-size:clamp(1em, 3vw, 1.2em);">rythmes euclidiens</p>
        </header>
        <main>
            <div class="controls">
                <div class="transport">
                    <label for="xlsx-upload" class="custom-file-upload"><strong>importer</strong></label>
                    <input type="file" id="xlsx-upload" accept=".xlsx">
                    <button id="play-pause-button">jouer</button>
                    <button id="export-button">exporter</button>
                    <div class="bpm-control">
                        <label for="bpm"><strong>tempo</strong></label>
                        <input type="number" id="bpm" value="140" min="20" max="240">
                    </div>
                </div>
                <div id="sequencers"></div>
                <button id="add-sequencer">ajouter une piste</button>
            </div>
            <div id="concentric-visualization" class="concentric-steps"></div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/10.1.0/nouislider.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let audioContext;
            let isPlaying = false;
            let currentStep = 0;
            let bpm = 140;
            let timerID;
            let sequencers = [];
            const lookahead = 25.0;
            const scheduleAheadTime = 0.1;

            const playPauseButton = document.getElementById('play-pause-button');
            const bpmInput = document.getElementById('bpm');
            const addSequencerButton = document.getElementById('add-sequencer');
            const sequencersContainer = document.getElementById('sequencers');
            const concentricContainer = document.getElementById('concentric-visualization');
            const xlsxUploadInput = document.getElementById('xlsx-upload');
            const exportButton = document.getElementById('export-button');

            function initAudioContext() {
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } catch (e) {
                        alert('L\'API Web Audio n\'est pas supportée par ce navigateur.');
                    }
                }
            }

            const soundSynth = {
                kick: (time) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.frequency.setValueAtTime(80, time);
                    gain.gain.setValueAtTime(0.6, time);
                    osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.4);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
                    osc.start(time);
                    osc.stop(time + 0.4);
                    const noise = audioContext.createBufferSource();
                    const bufferSize = audioContext.sampleRate * 0.05;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    let output = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) { output[i] = (Math.random() * 2 - 1) * 0.1; }
                    noise.buffer = buffer;
                    const noiseGain = audioContext.createGain();
                    noise.connect(noiseGain);
                    noiseGain.connect(audioContext.destination);
                    noiseGain.gain.setValueAtTime(0.2, time);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                    noise.start(time);
                    noise.stop(time + 0.05);
                },
                snare: (time) => {
                    const noise = audioContext.createBufferSource();
                    const bufferSize = audioContext.sampleRate;
                    const buffer = audioContext.createBuffer(1, bufferSize, bufferSize);
                    let output = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
                    noise.buffer = buffer;
                    const noiseFilter = audioContext.createBiquadFilter();
                    noiseFilter.type = 'highpass';
                    noiseFilter.frequency.value = 1500;
                    noise.connect(noiseFilter);
                    const noiseEnvelope = audioContext.createGain();
                    noiseFilter.connect(noiseEnvelope);
                    noiseEnvelope.connect(audioContext.destination);
                    noiseEnvelope.gain.setValueAtTime(0.5, time);
                    noiseEnvelope.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
                    noise.start(time);
                    noise.stop(time + 0.15);
                    const osc = audioContext.createOscillator();
                    const oscEnvelope = audioContext.createGain();
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(120, time);
                    osc.connect(oscEnvelope);
                    oscEnvelope.connect(audioContext.destination);
                    oscEnvelope.gain.setValueAtTime(0.9, time);
                    oscEnvelope.gain.exponentialRampToValueAtTime(0.01, time + 0.12);
                    osc.start(time);
                    osc.stop(time + 0.12);
                },
                hihat: (time) => {
                    const noise = audioContext.createBufferSource();
                    const bufferSize = audioContext.sampleRate * 0.03;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    let output = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
                    noise.buffer = buffer;
                    const bandpass = audioContext.createBiquadFilter();
                    bandpass.type = 'bandpass';
                    bandpass.frequency.value = 8000;
                    bandpass.Q.value = 5;
                    const gainNode = audioContext.createGain();
                    noise.connect(bandpass);
                    bandpass.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    gainNode.gain.setValueAtTime(0.6, time);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, time + 0.03);
                    noise.start(time);
                    noise.stop(time + 0.03);
                },
                shaker: (time) => {
                    const noise = audioContext.createBufferSource();
                    const bufferSize = audioContext.sampleRate * 0.1;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    let output = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
                    noise.buffer = buffer;
                    const bandpass = audioContext.createBiquadFilter();
                    bandpass.type = 'bandpass';
                    bandpass.frequency.setValueAtTime(4500, time);
                    bandpass.Q.value = 6;
                    const gainNode = audioContext.createGain();
                    noise.connect(bandpass);
                    bandpass.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    gainNode.gain.setValueAtTime(0.8, time);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, time + 0.08);
                    noise.start(time);
                    noise.stop(time + 0.08);
                    const reverb = audioContext.createConvolver();
                    const reverbTime = 0.3;
                    const reverbBuffer = audioContext.createBuffer(1, audioContext.sampleRate * reverbTime, audioContext.sampleRate);
                    let reverbData = reverbBuffer.getChannelData(0);
                    for (let i = 0; i < reverbData.length; i++) {
                        reverbData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / reverbData.length, 2);
                    }
                    reverb.buffer = reverbBuffer;
                    const reverbGain = audioContext.createGain();
                    noise.connect(reverb);
                    reverb.connect(reverbGain);
                    reverbGain.connect(audioContext.destination);
                    reverbGain.gain.setValueAtTime(0.3, time);
                    reverbGain.gain.exponentialRampToValueAtTime(0.01, time + reverbTime);
                },
                tom: (time) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(250, time);
                    gain.gain.setValueAtTime(0.8, time);
                    osc.frequency.exponentialRampToValueAtTime(100, time + 0.4);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
                    osc.start(time);
                    osc.stop(time + 0.5);
                },
                clap: (time) => {
                    const noise = audioContext.createBufferSource();
                    const bufferSize = audioContext.sampleRate;
                    const buffer = audioContext.createBuffer(1, bufferSize, bufferSize);
                    let output = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
                    noise.buffer = buffer;
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = 1500;
                    filter.Q.value = 2;
                    const envelope = audioContext.createGain();
                    noise.connect(filter);
                    filter.connect(envelope);
                    envelope.connect(audioContext.destination);
                    envelope.gain.setValueAtTime(1, time);
                    envelope.gain.exponentialRampToValueAtTime(0.1, time + 0.02);
                    envelope.gain.setValueAtTime(0, time + 0.021);
                    envelope.gain.linearRampToValueAtTime(1, time + 0.03);
                    envelope.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                    noise.start(time);
                    noise.stop(time + 0.2);
                },
                subBass: (time) => {
                    const osc1 = audioContext.createOscillator();
                    const osc2 = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();
                    osc1.type = 'sine';
                    osc2.type = 'triangle';
                    osc1.frequency.setValueAtTime(60, time);
                    osc2.frequency.setValueAtTime(60, time);
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(200, time);
                    filter.Q.value = 1.5;
                    osc1.connect(filter);
                    osc2.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioContext.destination);
                    gain.gain.setValueAtTime(0.7, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.7);
                    const lfo = audioContext.createOscillator();
                    const lfoGain = audioContext.createGain();
                    lfo.type = 'sine';
                    lfo.frequency.setValueAtTime(4, time);
                    lfoGain.gain.setValueAtTime(5, time);
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc1.frequency);
                    lfoGain.connect(osc2.frequency);
                    lfo.start(time);
                    osc1.start(time);
                    osc2.start(time);
                    osc1.stop(time + 0.7);
                    osc2.stop(time + 0.7);
                    lfo.stop(time + 0.7);
                },
                synthBell: (time) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(880.0, time);
                    gain.gain.setValueAtTime(0.6, time);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + 1.2);
                    osc.start(time);
                    osc.stop(time + 1.5);
                },
                synthSaw: (time) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.type = 'sawtooth';
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(2000, time);
                    osc.frequency.setValueAtTime(220.0, time);
                    gain.gain.setValueAtTime(0.4, time);
                    filter.frequency.exponentialRampToValueAtTime(400, time + 0.4);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
                    osc.start(time);
                    osc.stop(time + 0.5);
                },
                marimba: (time) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, time);
                    gain.gain.setValueAtTime(0.7, time);
                    osc.frequency.exponentialRampToValueAtTime(220, time + 0.3);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                    osc.start(time);
                    osc.stop(time + 0.5);
                },
                piano: (time) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(261.63, time);
                    gain.gain.setValueAtTime(0.8, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 1.0);
                    osc.start(time);
                    osc.stop(time + 1.0);
                },
                bongo: (time) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(300, time);
                    gain.gain.setValueAtTime(0.8, time);
                    osc.frequency.exponentialRampToValueAtTime(150, time + 0.2);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
                    osc.start(time);
                    osc.stop(time + 0.3);
                },
                guitar: (time) => {
                    const osc1 = audioContext.createOscillator();
                    const osc2 = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();
                    osc1.type = 'sine';
                    osc2.type = 'sawtooth';
                    osc1.frequency.setValueAtTime(220, time);
                    osc2.frequency.setValueAtTime(220, time);
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(1500, time);
                    filter.Q.value = 1;
                    osc1.connect(filter);
                    osc2.connect(filter);
                    filter.connect(gain);
                    gain.connect(audioContext.destination);
                    gain.gain.setValueAtTime(0.8, time);
                    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
                    osc1.start(time);
                    osc2.start(time);
                    osc1.stop(time + 0.3);
                    osc2.stop(time + 0.3);
                }
            };

            function playSound(time, instrument) {
                if (soundSynth[instrument]) {
                    soundSynth[instrument](time);
                } else {
                    console.error(`Instrument non trouvé : ${instrument}`);
                }
            }

            function euclidean(steps, pulses) {
                steps = parseInt(steps);
                pulses = parseInt(pulses);
                if (pulses > steps || pulses <= 0 || isNaN(steps) || isNaN(pulses)) {
                    return new Array(steps).fill(0);
                }
                if (pulses === steps) {
                    return new Array(steps).fill(1);
                }
                let pattern = [];
                let counts = [];
                let remainders = [];
                let divisor = steps - pulses;
                remainders.push(pulses);
                let level = 0;
                while (true) {
                    counts.push(Math.floor(divisor / remainders[level]));
                    remainders.push(divisor % remainders[level]);
                    divisor = remainders[level];
                    level += 1;
                    if (remainders[level] <= 1) break;
                }
                counts.push(divisor);
                function build(level) {
                    if (level === -1) pattern.push(0);
                    else if (level === -2) pattern.push(1);
                    else {
                        for (let i = 0; i < counts[level]; i++) build(level - 1);
                        if (remainders[level] !== 0) build(level - 2);
                    }
                }
                build(level);
                return pattern.reverse();
            }

            function adjustColor(hex, percent) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgb(${Math.max(0, Math.min(255, r + (r * percent / 100)))}, ${Math.max(0, Math.min(255, g + (g * percent / 100)))}, ${Math.max(0, Math.min(255, b + (b * percent / 100)))})`;
            }

            let nextNoteTime = 0.0;
            function scheduler() {
                while (nextNoteTime < audioContext.currentTime + scheduleAheadTime) {
                    const maxSteps = getMaxSteps();
                    if (maxSteps > 0) {
                        const currentGlobalStep = currentStep % maxSteps;
                        sequencers.forEach(seq => {
                            if (seq.steps > 0) {
                                const currentLocalStep = currentGlobalStep % seq.steps;
                                if (seq.pattern[currentLocalStep] === 1) {
                                    playSound(nextNoteTime, seq.instrument);
                                    const stepElements = concentricContainer.querySelectorAll(`.step[data-seq-id="${seq.id}"]`);
                                    stepElements.forEach(el => {
                                        el.classList.remove('current');
                                        if (seq.pattern[el.dataset.stepIndex] !== 1) {
                                            el.style.background = '#e0e0e0';
                                        }
                                    });
                                    const currentEl = concentricContainer.querySelector(`.step[data-seq-id="${seq.id}"][data-step-index="${currentLocalStep}"]`);
                                    if (currentEl && seq.pattern[currentLocalStep] === 1) {
                                        currentEl.classList.add('current');
                                        currentEl.style.background = `linear-gradient(145deg, ${instrumentColors[seq.instrument] || '#e0e0e0'}, ${adjustColor(instrumentColors[seq.instrument] || '#e0e0e0', -20)})`;
                                    }
                                }
                            }
                        });
                        const secondsPerBeat = 60.0 / bpm;
                        const secondsPerStep = secondsPerBeat / 4;
                        nextNoteTime += secondsPerStep;
                    }
                    currentStep = (currentStep + 1) % (getMaxSteps() || 1);
                }
                timerID = window.setTimeout(scheduler, lookahead);
            }

            function play() {
                if (isPlaying) return;
                if (sequencers.length === 0) {
                    alert('Ajoutez au moins une piste avant de jouer.');
                    return;
                }
                initAudioContext();
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                isPlaying = true;
                currentStep = 0;
                nextNoteTime = audioContext.currentTime + 0.1;
                scheduler();
                playPauseButton.textContent = 'arrêter';
                playPauseButton.classList.add('playing');
                updateNeedleAnimation();
                console.log('Lecture démarrée : l\'animation de l\'aiguille devrait fonctionner');
            }

            function stop() {
                if (!isPlaying) return;
                isPlaying = false;
                window.clearTimeout(timerID);
                playPauseButton.textContent = 'jouer';
                playPauseButton.classList.remove('playing');
                const allCurrent = concentricContainer.querySelectorAll('.current');
                allCurrent.forEach(el => {
                    el.classList.remove('current');
                    const seqId = el.dataset.seqId;
                    const seq = sequencers.find(s => s.id == seqId);
                    const stepIndex = parseInt(el.dataset.stepIndex);
                    if (seq && seq.pattern[stepIndex] === 1) {
                        el.style.background = `linear-gradient(145deg, ${instrumentColors[seq.instrument] || '#e0e0e0'}, ${adjustColor(instrumentColors[seq.instrument] || '#e0e0e0', -20)})`;
                    } else {
                        el.style.background = '#e0e0e0';
                    }
                });
                const needle = concentricContainer.querySelector('.needle');
                if (needle) {
                    needle.classList.remove('playing');
                    needle.style.animation = 'none';
                    needle.style.transform = 'translate(-50%, -100%) rotate(0deg)';
                    console.log('Aiguille arrêtée et réinitialisée à 0 degré');
                } else {
                    console.error('Élément aiguille non trouvé dans stop()');
                }
            }

            function getMaxSteps() {
                if (sequencers.length === 0) return 16;
                return sequencers.reduce((max, seq) => Math.max(max, seq.steps), 0);
            }

            function updateNeedleAnimation() {
                const needle = concentricContainer.querySelector('.needle');
                if (!needle) {
                    console.error('Élément aiguille non trouvé dans updateNeedleAnimation');
                    return;
                }
                const maxSteps = getMaxSteps();
                const secondsPerBeat = 60.0 / bpm;
                const secondsPerStep = secondsPerBeat / 4;
                const rotationDuration = secondsPerStep * maxSteps;
                needle.style.animation = isPlaying ? `rotate ${rotationDuration}s linear infinite` : 'none';
                if (isPlaying) {
                    needle.style.animationDelay = '0.1s';
                    needle.classList.add('playing');
                } else {
                    needle.style.transform = 'translate(-50%, -100%) rotate(0deg)';
                }
                console.log(`Animation de l'aiguille mise à jour : durée=${rotationDuration}s, isPlaying=${isPlaying}, délai=0.1s`);
            }

            const instrumentColors = {
                kick: '#FF6347',
                snare: '#4682B4',
                hihat: '#FFD700',
                shaker: '#3CB371',
                tom: '#FF4500',
                clap: '#9932CC',
                subBass: '#DC143C',
                synthBell: '#00CED1',
                synthSaw: '#FF69B4',
                marimba: '#228B22',
                piano: '#6A5ACD',
                bongo: '#DAA520',
                guitar: '#8B4513'
            };

            function redrawConcentric() {
                concentricContainer.innerHTML = '';
                if (sequencers.length === 0) {
                    console.log('Aucun séquenceur, effacement de la visualisation concentrique');
                    return;
                }
                const baseRadius = 50;
                const radiusIncrement = 30;
                const maxRadius = baseRadius + radiusIncrement * (sequencers.length - 1);
                const size = 2 * maxRadius + 60;
                concentricContainer.style.width = `${Math.min(size, window.innerWidth * 0.8)}px`;
                concentricContainer.style.height = `${Math.min(size, window.innerWidth * 0.8)}px`;
                const centerX = size / 2;
                const centerY = size / 2;

                sequencers.forEach((seq, ringIndex) => {
                    const radius = baseRadius + radiusIncrement * ringIndex;
                    const color = instrumentColors[seq.instrument] || '#e0e0e0';
                    for (let i = 0; i < seq.steps; i++) {
                        const stepDiv = document.createElement('div');
                        stepDiv.className = 'step';
                        if (seq.pattern[i] === 1) {
                            stepDiv.classList.add('active');
                            stepDiv.style.background = `linear-gradient(145deg, ${color}, ${adjustColor(color, -20)})`;
                        } else {
                            stepDiv.style.background = '#e0e0e0';
                        }
                        stepDiv.dataset.seqId = seq.id;
                        stepDiv.dataset.stepIndex = i;
                        const angle = (i / seq.steps) * 2 * Math.PI;
                        const x = centerX + radius * Math.cos(angle);
                        const y = centerY + radius * Math.sin(angle);
                        stepDiv.style.left = `${x}px`;
                        stepDiv.style.top = `${y}px`;
                        concentricContainer.appendChild(stepDiv);
                    }
                });

                const needle = document.createElement('div');
                needle.className = 'needle';
                needle.style.left = `${centerX}px`;
                needle.style.top = `${centerY}px`;
                needle.style.transform = 'translate(-50%, -100%) rotate(0deg)';
                needle.innerHTML = `
                    <svg class="needle-svg" width="10" height="${maxRadius}" viewBox="0 0 10 ${maxRadius}">
                        <path d="M5 0 L8 ${maxRadius} A3 3 0 0 1 2 ${maxRadius} Z" fill="#2c3e50"/>
                    </svg>
                `;
                concentricContainer.appendChild(needle);
                console.log('Aiguille ajoutée au DOM à 0 degré avec base semi-circulaire centrée sur l\'axe de rotation');

                updateNeedleAnimation();
            }

            let sequencerIdCounter = 0;
            const defaultInstruments = ['kick', 'snare', 'hihat', 'clap', 'tom', 'shaker', 'subBass', 'synthSaw', 'synthBell', 'marimba', 'piano', 'bongo', 'guitar'];

            function createSequencer(instrument = defaultInstruments[sequencerIdCounter % defaultInstruments.length], pulses = 5, steps = 16) {
                const id = sequencerIdCounter++;
                const seqContainer = document.createElement('div');
                seqContainer.className = 'sequencer';
                seqContainer.dataset.id = id;

                const controls = document.createElement('div');
                controls.className = 'sequencer-controls';
                controls.innerHTML = `
                    <div class="control-group">
                        <div class="instrument-group">
                            <label for="instrument-${id}">instrument :</label>
                            <select id="instrument-${id}">
                                <option value="kick">kick</option>
                                <option value="snare">snare</option>
                                <option value="hihat">hi-hat</option>
                                <option value="shaker">shaker</option>
                                <option value="tom">tom</option>
                                <option value="clap">clap</option>
                                <option value="subBass">sub bass</option>
                                <option value="synthBell">synth bell</option>
                                <option value="synthSaw">synth saw</option>
                                <option value="marimba">marimba</option>
                                <option value="piano">piano</option>
                                <option value="bongo">bongo</option>
                                <option value="guitar">guitar</option>
                            </select>
                        </div>
                        <label for="slider-${id}" id="slider-value-${id}">E(${pulses}, ${steps}) :</label>
                        <div id="slider-${id}" class="noUiSlider"></div>
                        <button class="remove-sequencer">supprimer</button>
                    </div>
                `;

                seqContainer.append(controls);
                sequencersContainer.append(seqContainer);

                const slider = seqContainer.querySelector(`#slider-${id}`);
                const sliderValue = seqContainer.querySelector(`#slider-value-${id}`);
                const instrumentSelect = seqContainer.querySelector(`#instrument-${id}`);
                const removeButton = seqContainer.querySelector('.remove-sequencer');
                instrumentSelect.value = instrument;

                const newSequencer = {
                    id: id,
                    pulses: pulses,
                    steps: steps,
                    instrument: instrumentSelect.value,
                    pattern: [],
                    element: seqContainer
                };

                function updatePattern() {
                    newSequencer.pulses = Math.round(slider.noUiSlider.get()[0]);
                    newSequencer.steps = Math.round(slider.noUiSlider.get()[1]);
                    if (newSequencer.pulses > newSequencer.steps) {
                        newSequencer.pulses = newSequencer.steps;
                        slider.noUiSlider.set([newSequencer.pulses, newSequencer.steps]);
                    }
                    sliderValue.textContent = `E(${newSequencer.pulses}, ${newSequencer.steps}) :`;
                    newSequencer.pattern = euclidean(newSequencer.steps, newSequencer.pulses);
                    redrawConcentric();
                }

                setTimeout(() => {
                    noUiSlider.create(slider, {
                        start: [pulses, steps],
                        connect: true,
                        range: {
                            'min': 1,
                            'max': 32
                        },
                        step: 1,
                        tooltips: [false, false],
                        format: {
                            to: value => Math.round(value),
                            from: value => Math.round(value)
                        }
                    });

                    slider.noUiSlider.on('update', () => {
                        updatePattern();
                    });

                    instrumentSelect.addEventListener('change', (e) => {
                        newSequencer.instrument = e.target.value;
                        updatePattern();
                    });

                    removeButton.addEventListener('click', () => {
                        sequencers = sequencers.filter(s => s.id !== id);
                        seqContainer.remove();
                        redrawConcentric();
                    });

                    sequencers.push(newSequencer);
                    updatePattern();
                }, 0);
            }

            xlsxUploadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const workbook = XLSX.read(event.target.result, { type: 'array' });
                            const firstSheetName = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[firstSheetName];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                            const filteredData = jsonData.filter(row => row.some(cell => cell !== '' && cell != null && cell !== undefined));
                            const expectedHeaders = ['instrument', 'battements', 'nombre de temps'];
                            const headers = filteredData[0] || [];
                            const headersValid = expectedHeaders.every((header, index) => headers[index] === header);
                            if (!headersValid) {
                                throw new Error('Le fichier XLSX doit avoir les colonnes : instrument, battements, nombre de temps');
                            }

                            sequencers.forEach(seq => seq.element.remove());
                            sequencers = [];
                            let validSequencers = 0;

                            filteredData.slice(1).forEach(row => {
                                const [instrument, pulses, steps] = row.map(item => item.toString().trim());
                                if (instrument === 'tempo') {
                                    const tempoValue = parseInt(pulses);
                                    if (!isNaN(tempoValue) && tempoValue >= 20 && tempoValue <= 240) {
                                        bpm = tempoValue;
                                        bpmInput.value = tempoValue;
                                        console.log(`Tempo importé : ${tempoValue} BPM`);
                                    }
                                } else if (instrument && pulses && steps && defaultInstruments.includes(instrument)) {
                                    const pulsesNum = parseInt(pulses);
                                    const stepsNum = parseInt(steps);
                                    if (!isNaN(pulsesNum) && !isNaN(stepsNum) && pulsesNum > 0 && pulsesNum <= stepsNum && stepsNum <= 32) {
                                        createSequencer(instrument, pulsesNum, stepsNum);
                                        validSequencers++;
                                    }
                                }
                            });

                            redrawConcentric();
                            updateNeedleAnimation();
                            if (validSequencers > 0) {
                                alert(`${validSequencers} piste(s) importée(s) avec succès.`);
                            } else {
                                alert('Aucune piste valide trouvée dans le fichier XLSX.');
                            }
                        } catch (e) {
                            console.error('Erreur lors de la lecture du fichier XLSX:', e);
                            alert(`Erreur lors de la lecture du fichier XLSX: ${e.message}`);
                        }
                    };
                    reader.onerror = () => {
                        alert('Erreur lors de la lecture du fichier.');
                    };
                    reader.readAsArrayBuffer(file);
                }
            });

            exportButton.addEventListener('click', () => {
                if (sequencers.length === 0) {
                    alert('Aucun séquenceur à exporter.');
                    return;
                }
                const data = [['instrument', 'battements', 'nombre de temps']];
                data.push(['tempo', bpm, '']);
                sequencers.forEach(seq => {
                    data.push([seq.instrument, seq.pulses, seq.steps]);
                });
                const worksheet = XLSX.utils.aoa_to_sheet(data);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, 'Rythmes');
                XLSX.writeFile(workbook, 'rythmes.xlsx');
                console.log('Fichier XLSX exporté avec tempo :', bpm);
            });

            playPauseButton.addEventListener('click', () => { isPlaying ? stop() : play(); });
            bpmInput.addEventListener('input', (e) => { 
                const newBpm = parseInt(e.target.value);
                if (!isNaN(newBpm) && newBpm >= 20 && newBpm <= 240) {
                    bpm = newBpm;
                    updateNeedleAnimation();
                    console.log(`Tempo modifié manuellement : ${bpm} BPM`);
                }
            });
            addSequencerButton.addEventListener('click', () => createSequencer());

            // Pas d'initialisation de séquenceurs par défaut
            redrawConcentric();
        });
    </script>
</body>
</html>